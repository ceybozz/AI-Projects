# Import necessary libraries
from pyamaze import maze, agent, textLabel
from queue import PriorityQueue

# ------------------------------
# Heuristic Function: Manhattan Distance
# ------------------------------
def heuristic(cell1, cell2):
    """
    Calculate the Manhattan distance between two cells.
    
    Args:
        cell1 (tuple): Coordinates (row, col) of the first cell.
        cell2 (tuple): Coordinates (row, col) of the second cell.
        
    Returns:
        int: Manhattan distance between cell1 and cell2.
    """
    x1, y1 = cell1
    x2, y2 = cell2
    return abs(x1 - x2) + abs(y1 - y2)


# ------------------------------
# A* Search Algorithm
# ------------------------------
def aStarAlgorithm(myMaze):
    """
    Perform A* search on the maze to find the shortest path from start to goal.

    Args:
        myMaze (maze): A maze object generated by pyamaze.

    Returns:
        dict: A dictionary representing the forward path.
    """
    # Define the start position (bottom-right corner)
    start = (myMaze.rows, myMaze.cols)
    
    # Initialize g_score (distance from start)
    g_score = {cell: float('inf') for cell in myMaze.grid}
    g_score[start] = 0

    # Initialize f_score (g_score + heuristic estimate to goal)
    f_score = {cell: float('inf') for cell in myMaze.grid}
    f_score[start] = heuristic(start, (1, 1))

    # Priority queue to select the next node with lowest f_score
    open_set = PriorityQueue()
    open_set.put((f_score[start], heuristic(start, (1,1)), start))

    # To reconstruct the path later
    aStarPath = {}

    while not open_set.empty():
        # Get the cell with the lowest f_score
        current_Cell = open_set.get()[2]

        # Check if goal is reached (top-left corner)
        if current_Cell == (1, 1):
            break

        # Explore neighbors (North, East, South, West)
        for direction in 'NESW':
            if myMaze.maze_map[current_Cell][direction] == True:
                # Calculate the position of the neighbor
                if direction == 'N':
                    child_Cell = (current_Cell[0] - 1, current_Cell[1])
                elif direction == 'E':
                    child_Cell = (current_Cell[0], current_Cell[1] + 1)
                elif direction == 'S':
                    child_Cell = (current_Cell[0] + 1, current_Cell[1])
                elif direction == 'W':
                    child_Cell = (current_Cell[0], current_Cell[1] - 1)

                # Update scores for the neighbor
                new_g_score = g_score[current_Cell] + 1
                new_f_score = new_g_score + heuristic(child_Cell, (1,1))

                # If this path to child_Cell is better, update
                if new_f_score < f_score[child_Cell]:
                    g_score[child_Cell] = new_g_score
                    f_score[child_Cell] = new_f_score
                    open_set.put((new_f_score, heuristic(child_Cell, (1,1)), child_Cell))
                    aStarPath[child_Cell] = current_Cell

    # Reconstruct the forward path from start to goal
    fwdPath = {}
    cell = (1, 1)
    while cell != start:
        fwdPath[aStarPath[cell]] = cell
        cell = aStarPath[cell]
    
    return fwdPath


# ------------------------------
# Main Execution
# ------------------------------
if __name__ == '__main__':
    # Create a maze of size 10 rows x 15 columns
    myMaze = maze(10, 15)
    myMaze.CreateMaze()

    # Find the path using A* Algorithm
    path = aStarAlgorithm(myMaze)

    # Create an agent to trace the path
    a = agent(myMaze, footprints=True)
    myMaze.tracePath({a: path})

    # Display the number of steps in the path
    text = textLabel(myMaze, 'A* Path Steps', len(path) + 1)

    # Run the maze visualization
    myMaze.run()
